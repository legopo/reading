## 第1章: 悪き構造の弊害を知覚する

### まとめ

- 技術駆動命名、連番命名
- 条件分岐のネスト
- データクラス(データのインスタンス変数のみを持ったクラス)を作ると、そのデータに対する処理をするクラスが別に必要になるので重複した実装が起きる可能性が高まる

---

## 第2章: 設計の初歩

### まとめ

- 変数名を省略しない
- 再代入せずに目的ごとの変数を用意する
- 意味のある単位で処理をメソッド化する
- データとロジックをクラスにまとめる

---

## 第3章: クラス設計

### まとめ

- クラス単体で正常動作するように設計
- メソッド内では必ずインスタンス変数を使う
- クラスの自己防衛責務 ⇒ クラスの一つ一つが品質的に完結している状態(他のクラスに初期化やデータのチェックをしてもらわずに自クラスで完結する状態)
- コンストラクタで確実にインスタンス変数を(正常値で)設定する ⇒ インスタンス変数は全てコンストラクタでバリデーションして初期化する
- ガード節を使って例外を投げてしまうとわかりやすい
- インスタンス変数を上書きしない(副作用を避けるためにイミュータブルにして(phpにはfinalはない？)、メソッドでは新しくインスタンスをnew して返却することで新しい値を使うような形にできる) p28~29
- メソッド引数やローカル変数も不変にする
- メソッド引数にもintやstringじゃなくて独自の型を指定する ⇒ 値の渡し間違い防止
- メソッド内にもバリデーションを設置
- 必要のないメソッドは定義しない
- p35 表1がまとめ
- クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくり
- 関係ロジックがまとまっていて(高凝集)、メソッドのみを外部公開する状態がカプセル化
- p37 まとめ, p40 jsの例

---

### メモ

---

## 第4章: 不変の活用

### まとめ

- 再代入しない
- インスタンス変数、ローカル変数、メソッド引数全てイミュータブルにする
- 主作用 ⇒ メソッドが引数を受け取り、値を返すこと
- 副作用 ⇒ 主作用以外の状態変更があること(インスタンス変数、グローバル変数、I/O, 引数の変更)
- メソッドの理想は「引数で状態を受け取り、状態変更をせず、値を返すだけ」（状態 = データ ?）
- ○ メソッド内でインスタンス変数を読む
- x メソッド内でインスタンス変数を変更する
- ただ、オブジェクト指向では、副作用のない関数を厳密に作り込むよりも、クラスのスコープ内で影響を閉じ込められればいい
- 基本的に不変をデフォルトとして、ループなど局所的なスコープに限定できる場合のみ可変を許可するイメージ
- 状態変更をするメソッド = ミューテーター
- もし、インスタンス変数を可変にする場合は、正しく状態変更できるようなメソッド設計をする(hpは負の数にはならないので、オーバーキルされた場合も0として扱うようにするというようなイメージ)

---

### メモ

---

## 第5章: 低凝集

### まとめ

- 凝集度 ⇒ モジュール内における、データとロジックの関係性の強さ
- 高凝集は変更に強い
- staticメソッドはインスタンス変数が使えないので、低凝集になりやすい。
- new する時のパターン多くなる場合(生成ロジックが多い)にprivateコンストラクタ+ファクトリーメソッド(static)というやり方をする
- 共通処理クラスは低凝集を招くので安易に作らない ⇒ 関連のないロジックが集まりやすく、共通化や再利用性への理解が不足しやすいかららしい。
- 横断的関心事 ⇒ ログ出力, 例外処理, キャッシュ etc
- 横断的関心事は共通クラスを作ってstaticにしてもいい。
- プリミティブ型執着 ⇒ メソッドの引数や返り値をプリミティブ型だけで作成する事
- プリミティブ型執着は、重複ロジックや低凝集を生みやすくなる(個別のクラスの値を渡せばいいものを、例えばintとかで渡してしまうと、再度値のバリデーションなど必要になったりするということ)
- 引数が多いメソッドができた場合、その引数をインスタンス変数として持つクラスとして設計するのを考えてみる
- メソッドチェインはよくない。利用するオブジェクトの中身は知る必要がない(デルメルの法則)
- 「尋ねるな、命じろ」(オブジェクトの内部状態(変数)に応じて呼び出し側が判断するのではなく、呼ぶ側はただ呼ぶだけで、呼ばれた側で適切に制御や処理しましょうという考え方)

---

### メモ

- 共通処理クラスの作成は、効率を考えるとアプリの規模が一定で収まることがわかっている場合は別にいいんじゃないかと思う。そのアプリのビジネスロジックに関わりのない一般的な計算や処理(今日を取得とか)を集めるというような用途であれば特に
- クラスって、インスタンス変数の状態変化をまとめる仕組みという定義？側面？ ⇒ 変化する値(インスタンス変数の値自体は不変にして、新たにnewしたものを返すというのは別の話。)はインスタンス変数として宣言しておく?
- メソッドチェーンは自分でクラス作る時はやらないほうがいいっぽい？よく分からない

---

## 第6章: 条件分岐

### まとめ

- ifのネストやelse句はできるだけ避けて、早期returnする。そうすると「条件」と「実行」の記述が分離され見通しが良くなり、「条件」「実行」どちらも追加が容易になる

```jsx
// 条件
if (!hoge) { return; }
if (!fuga) { return; }

// 実行
piyo();
```

- switch文は危険。同条件のswitch文が乱立して仕様変更時のcaseの追加漏れなどが起きる。同条件のswitch文は１箇所にまとめて書く。
- 人間の注意力には限界がある
- switch文はinterfaceに置き換える ⇒ 　ストラテジーパターン
- 条件分岐は「ルール」と「ポリシー」で集約しておく ⇒ 複数箇所にロジックが分散せず、仕様変更時の漏れ、手間共に改善される
- 分岐を書きそうになったら、まずinterface設計　を意識する

|  | 初級者 | 中級者~ |
| --- | --- | --- |
| 分岐 | 迷わずif, switch | interface設計 |
| 分岐ごとの処理 | ベタ書き | クラス設計 |
- フラグ引数(処理の分岐条件をbooleanやintの引数で判断する事)は、読み手のコードの内容把握をしづらくする

---

### メモ

- Laravelのポリシーとルールは、フレームワークが用意してくれた機能のまま使えばリクエストごとに書き分けていくことになってしまうので、同じ分岐が複数ある場合は処理をまとめた上位のクラスを作って、そちらを呼び出して使うようにするのが良さそう
- **リスコフの置換原則**
- もし多くの分岐でインターフェースを作るとしたらそれだけで結構手間がかかると思うので、どのパターンで使うべきか、使わないべきかを考えながらコード書くようにしてみる。「分岐ごとの処理」はクラス設計せよとのことだけど、メソッド分けで十分な場合もあるんじゃないかなと思うのでそこも

## 第7章: コレクション

### まとめ

- ループや条件分岐は、言語のコレクションメソッドに置き換える。 ⇒ 見通しをよくする。車輪の再発明をしない
- ループを使う場合は、早期continue, 早期breakを使う ⇒ 見通しをよくする
- コレクションに関する処理は低凝集に陥りやすい ⇒ ファーストクラスコレクション の設計パターンを使って、コレクション型のインスタンス変数とそれを正常に操作するメソッドを実装する。

### メモ

- 実装例が載っているので本を再度参照する

---

## 第8章: 密結合

### まとめ

- 単一責任の原則に沿ってクラスを設計する。 責務によってクラスが分かれていると、仕様変更によって追加や変更があっても互いに影響がない ⇨ 疎結合
- DRYは誤用が多い。同じような 似たようなロジックでも概念がちがければDRYにせず書き分ける
- 継承は推奨しない ⇒ スーパークラス依存になる
- 継承は共通コード置き場になりやすく、責務が分散しやすい。(子クラスに実装されているべき知識が親にあることになり、それが複数になるとよりロジックが追いづらい)
- Utilのようなクラスで責務の違うメソッドが実装されていて、それぞれに対応するインスタンス変数があるような場合、密結合を避けるためクラスを分割する
- public を使いすぎると、関係しあってほしくないクラスからもメソッドが呼び出されるようになり蜜結合になる。pubicは限定的に使う
- 逆にprivateばかりでも、多くの責務を持ったクラスになりやすい
- public, private, protectedなどは適切に使う
- スマートUI(= 表示関連クラスの中に表示以外のロジックもいる状態)は密結合になり変更が困難になる。「表示」「表示以外」できちんと責務を分ける
- 巨大データクラス(= ecサイトでありがちなOrderクラスなど)は意識していないと巨大化しやすいので、責務を考えて分割
- トランザクションスクリプトパターン (= メソッドの中に一連の処理手順が長く続いている状態)を避ける。重症化すると神クラスになる。単一責任に基づいて分割する
- 単一責任の原則を遵守するとどんなに長くても200行程度、大体は100行程度のクラスになる

### メモ

- 継承 ⇒ 委譲,DI
- p157-158 で、継承から委譲(コンポジション構造)にすると、継承の時は親だったクラスのロジックが変更されても委譲先ではその変更の影響を受けないって書いてあるけどよく分からない。委譲の場合、PhysicalAttackクラスの置き換えが楽だからということ？

```java
// 委譲元, 親
class PhysicalAttack {
  int singleAttackDamage() {  /* 何かしらの実装 */ }

  int doubleAttackDamage() { /* 何かしらの実装 */ }
}

// --- 継承パターン ---
// 子
class FighterPhysicalAttack extends PhysicalAttack {
	@Override
  int singleAttackDamage() {
    return super.singleAttackDamage() + 20;
  }

	@Override
  int doubleAttackDamage() {
    return super.doubleAttackDamage() + 10;
  }
}

// --- 委譲パターン ---
// 委譲先
class FighterPhysicalAttack {
  private final PhysicalAttack physicalAttack;

  int singleAttackDamage() {
    return physicalAttack.singleAttackDamage() + 20; // <--- 委譲したとしても、委譲元が変更されたら影響受けるのでは？？？
  }

  int doubleAttackDamage() {
    return physicalAttack.doubleAttackDamage() + 20; // <--- 委譲したとしても、委譲元が変更されたら影響受けるのでは？？？
  }
}
```

- [https://ikenox.info/blog/inheritance-and-delegation-and-interface/#:~:text=継承は子が親,ことによる不都合が生じる。](https://ikenox.info/blog/inheritance-and-delegation-and-interface/#:~:text=%E7%B6%99%E6%89%BF%E3%81%AF%E5%AD%90%E3%81%8C%E8%A6%AA,%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%8D%E9%83%BD%E5%90%88%E3%81%8C%E7%94%9F%E3%81%98%E3%82%8B%E3%80%82)