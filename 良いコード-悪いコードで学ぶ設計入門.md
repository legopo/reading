## 第1章: 悪き構造の弊害を知覚する

### まとめ

- 技術駆動命名、連番命名
- 条件分岐のネスト
- データクラス(データのインスタンス変数のみを持ったクラス)を作ると、そのデータに対する処理をするクラスが別に必要になるので重複した実装が起きる可能性が高まる

---

## 第2章: 設計の初歩

### まとめ

- 変数名を省略しない
- 再代入せずに目的ごとの変数を用意する
- 意味のある単位で処理をメソッド化する
- データとロジックをクラスにまとめる

---

## 第3章: クラス設計

### まとめ

- クラス単体で正常動作するように設計
- メソッド内では必ずインスタンス変数を使う
- クラスの自己防衛責務 ⇒ クラスの一つ一つが品質的に完結している状態(他のクラスに初期化やデータのチェックをしてもらわずに自クラスで完結する状態)
- コンストラクタで確実にインスタンス変数を(正常値で)設定する ⇒ インスタンス変数は全てコンストラクタでバリデーションして初期化する
- ガード節を使って例外を投げてしまうとわかりやすい
- インスタンス変数を上書きしない(副作用を避けるためにイミュータブルにして(phpにはfinalはない？)、メソッドでは新しくインスタンスをnew して返却することで新しい値を使うような形にできる) p28~29
- メソッド引数やローカル変数も不変にする
- メソッド引数にもintやstringじゃなくて独自の型を指定する ⇒ 値の渡し間違い防止
- メソッド内にもバリデーションを設置
- 必要のないメソッドは定義しない
- p35 表1がまとめ
- クラス設計とは、インスタンス変数を不正状態に陥らせないための仕組みづくり
- 関係ロジックがまとまっていて(高凝集)、メソッドのみを外部公開する状態がカプセル化
- p37 まとめ, p40 jsの例

---

### メモ

---

## 第4章: 不変の活用

### まとめ

- 再代入しない
- インスタンス変数、ローカル変数、メソッド引数全てイミュータブルにする
- 主作用 ⇒ メソッドが引数を受け取り、値を返すこと
- 副作用 ⇒ 主作用以外の状態変更があること(インスタンス変数、グローバル変数、I/O, 引数の変更)
- メソッドの理想は「引数で状態を受け取り、状態変更をせず、値を返すだけ」（状態 = データ ?）
- ○ メソッド内でインスタンス変数を読む
- x メソッド内でインスタンス変数を変更する
- ただ、オブジェクト指向では、副作用のない関数を厳密に作り込むよりも、クラスのスコープ内で影響を閉じ込められればいい
- 基本的に不変をデフォルトとして、ループなど局所的なスコープに限定できる場合のみ可変を許可するイメージ
- 状態変更をするメソッド = ミューテーター
- もし、インスタンス変数を可変にする場合は、正しく状態変更できるようなメソッド設計をする(hpは負の数にはならないので、オーバーキルされた場合も0として扱うようにするというようなイメージ)

---

### メモ

---

## 第5章: 低凝集

### まとめ

- 凝集度 ⇒ モジュール内における、データとロジックの関係性の強さ
- 高凝集は変更に強い
- staticメソッドはインスタンス変数が使えないので、低凝集になりやすい。
- new する時のパターン多くなる場合(生成ロジックが多い)にprivateコンストラクタ+ファクトリーメソッド(static)というやり方をする
- 共通処理クラスは低凝集を招くので安易に作らない ⇒ 関連のないロジックが集まりやすく、共通化や再利用性への理解が不足しやすいかららしい。
- 横断的関心事 ⇒ ログ出力, 例外処理, キャッシュ etc
- 横断的関心事は共通クラスを作ってstaticにしてもいい。
- プリミティブ型執着 ⇒ メソッドの引数や返り値をプリミティブ型だけで作成する事
- プリミティブ型執着は、重複ロジックや低凝集を生みやすくなる(個別のクラスの値を渡せばいいものを、例えばintとかで渡してしまうと、再度値のバリデーションなど必要になったりするということ)
- 引数が多いメソッドができた場合、その引数をインスタンス変数として持つクラスとして設計するのを考えてみる
- メソッドチェインはよくない。利用するオブジェクトの中身は知る必要がない(デルメルの法則)
- 「尋ねるな、命じろ」(オブジェクトの内部状態(変数)に応じて呼び出し側が判断するのではなく、呼ぶ側はただ呼ぶだけで、呼ばれた側で適切に制御や処理しましょうという考え方)

---

### メモ

- 共通処理クラスの作成は、効率を考えるとアプリの規模が一定で収まることがわかっている場合は別にいいんじゃないかと思う。そのアプリのビジネスロジックに関わりのない一般的な計算や処理(今日を取得とか)を集めるというような用途であれば特に
- クラスって、インスタンス変数の状態変化をまとめる仕組みという定義？側面？ ⇒ 変化する値(インスタンス変数の値自体は不変にして、新たにnewしたものを返すというのは別の話。)はインスタンス変数として宣言しておく?
- メソッドチェーンは自分でクラス作る時はやらないほうがいいっぽい？よく分からない

---

## 第6章: 条件分岐

### まとめ

- ifのネストやelse句はできるだけ避けて、早期returnする。そうすると「条件」と「実行」の記述が分離され見通しが良くなり、「条件」「実行」どちらも追加が容易になる

```jsx
// 条件
if (!hoge) { return; }
if (!fuga) { return; }

// 実行
piyo();
```

- switch文は危険。同条件のswitch文が乱立して仕様変更時のcaseの追加漏れなどが起きる。同条件のswitch文は１箇所にまとめて書く。
- 人間の注意力には限界がある
- switch文はinterfaceに置き換える ⇒ 　ストラテジーパターン
- 条件分岐は「ルール」と「ポリシー」で集約しておく ⇒ 複数箇所にロジックが分散せず、仕様変更時の漏れ、手間共に改善される
- 分岐を書きそうになったら、まずinterface設計　を意識する

|  | 初級者 | 中級者~ |
| --- | --- | --- |
| 分岐 | 迷わずif, switch | interface設計 |
| 分岐ごとの処理 | ベタ書き | クラス設計 |
- フラグ引数(処理の分岐条件をbooleanやintの引数で判断する事)は、読み手のコードの内容把握をしづらくする

---

### メモ

- Laravelのポリシーとルールは、フレームワークが用意してくれた機能のまま使えばリクエストごとに書き分けていくことになってしまうので、同じ分岐が複数ある場合は処理をまとめた上位のクラスを作って、そちらを呼び出して使うようにするのが良さそう
- **リスコフの置換原則**
- もし多くの分岐でインターフェースを作るとしたらそれだけで結構手間がかかると思うので、どのパターンで使うべきか、使わないべきかを考えながらコード書くようにしてみる。「分岐ごとの処理」はクラス設計せよとのことだけど、メソッド分けで十分な場合もあるんじゃないかなと思うのでそこも

## 第7章: コレクション

### まとめ

- ループや条件分岐は、言語のコレクションメソッドに置き換える。 ⇒ 見通しをよくする。車輪の再発明をしない
- ループを使う場合は、早期continue, 早期breakを使う ⇒ 見通しをよくする
- コレクションに関する処理は低凝集に陥りやすい ⇒ ファーストクラスコレクション の設計パターンを使って、コレクション型のインスタンス変数とそれを正常に操作するメソッドを実装する。

### メモ

- 実装例が載っているので本を再度参照する

---

## 第8章: 密結合

### まとめ

- 単一責任の原則に沿ってクラスを設計する。 責務によってクラスが分かれていると、仕様変更によって追加や変更があっても互いに影響がない ⇨ 疎結合
- DRYは誤用が多い。同じような 似たようなロジックでも概念がちがければDRYにせず書き分ける
- 継承は推奨しない ⇒ スーパークラス依存になる
- 継承は共通コード置き場になりやすく、責務が分散しやすい。(子クラスに実装されているべき知識が親にあることになり、それが複数になるとよりロジックが追いづらい)
- Utilのようなクラスで責務の違うメソッドが実装されていて、それぞれに対応するインスタンス変数があるような場合、密結合を避けるためクラスを分割する
- public を使いすぎると、関係しあってほしくないクラスからもメソッドが呼び出されるようになり蜜結合になる。pubicは限定的に使う
- 逆にprivateばかりでも、多くの責務を持ったクラスになりやすい
- public, private, protectedなどは適切に使う
- スマートUI(= 表示関連クラスの中に表示以外のロジックもいる状態)は密結合になり変更が困難になる。「表示」「表示以外」できちんと責務を分ける
- 巨大データクラス(= ecサイトでありがちなOrderクラスなど)は意識していないと巨大化しやすいので、責務を考えて分割
- トランザクションスクリプトパターン (= メソッドの中に一連の処理手順が長く続いている状態)を避ける。重症化すると神クラスになる。単一責任に基づいて分割する
- 単一責任の原則を遵守するとどんなに長くても200行程度、大体は100行程度のクラスになる

---

### メモ

- 継承 ⇒ 委譲,DI
- p157-158 で、継承から委譲(コンポジション構造)にすると、継承の時は親だったクラスのロジックが変更されても委譲先ではその変更の影響を受けないって書いてあるけどよく分からない。委譲の場合、PhysicalAttackクラスの置き換えが楽だからということ？

```java
// 委譲元, 親
class PhysicalAttack {
  int singleAttackDamage() {  /* 何かしらの実装 */ }

  int doubleAttackDamage() { /* 何かしらの実装 */ }
}

// --- 継承パターン ---
// 子
class FighterPhysicalAttack extends PhysicalAttack {
	@Override
  int singleAttackDamage() {
    return super.singleAttackDamage() + 20;
  }

	@Override
  int doubleAttackDamage() {
    return super.doubleAttackDamage() + 10;
  }
}

// --- 委譲パターン ---
// 委譲先
class FighterPhysicalAttack {
  private final PhysicalAttack physicalAttack;

  int singleAttackDamage() {
    return physicalAttack.singleAttackDamage() + 20; // <--- 委譲したとしても、委譲元が変更されたら影響受けるのでは？？？
  }

  int doubleAttackDamage() {
    return physicalAttack.doubleAttackDamage() + 20; // <--- 委譲したとしても、委譲元が変更されたら影響受けるのでは？？？
  }
}
```

- [https://ikenox.info/blog/inheritance-and-delegation-and-interface/#:~:text=継承は子が親,ことによる不都合が生じる。](https://ikenox.info/blog/inheritance-and-delegation-and-interface/#:~:text=%E7%B6%99%E6%89%BF%E3%81%AF%E5%AD%90%E3%81%8C%E8%A6%AA,%E3%81%93%E3%81%A8%E3%81%AB%E3%82%88%E3%82%8B%E4%B8%8D%E9%83%BD%E5%90%88%E3%81%8C%E7%94%9F%E3%81%98%E3%82%8B%E3%80%82)

---

## 第9章: 設計の健全性をそこなうさまざまな悪魔たち

### まとめ

- どんな条件であっても決して実行されないコードをデッドコードと呼ぶ。可読性の低下、読むたびに何か意図があるのでは？という混乱、仕様変更により予期せぬ復活など、さまざまな弊害があるため、見つけ次第すぐに削除
- YAGNI原則 ⇒ 必要になった時のみ実装しなさい
- 先回りして作られたロジックには仕様がない
- 先回りで作り込んだ分だけ時間が無駄になる
- マジックナンバーを使わない
- nullを使うと、nullチェックが必要になる。nullを返さない、渡さない設計にする。
- 何らかの状態を持っていない、も立派な状態であって、nullはその状態すら存在していない状態
- 例外の握りつぶしは、不正状態なのに問題なく動いて見えるので非常に危険
- mvcのフレームワークなどで、models, controllers, viewsのようにディレクトリが分かれているのを、技術駆動パッケージングという。それぞれ関係するファイル同士が分かりにくくなるので、ビジネス概念として強く結びつくものを同じディレクトリにまとめる
- 設計にbestはありません。常にbetterを目指しましょう

---

### メモ

- vscodeのデッドコードの静的解析を調べる。現状でも使われてない変数は色が薄くなる
- null安全(nullが原因のエラーを発生させない仕組み)について調べる。Kotlinはnull非許容がデフォルト
- try catchでロギングだけもかなり危険だった。原因把握はできるけどそもそも気付けなくなる
- メタプログラミングという言葉を初めて知った。軽くしらべる
- 本の内容が理想の世界の追求という感じに思う。正直全てこの通りにやっていたら終わらなくなるので、必要なものを取捨選択して取り入れていくというスタンスがいいと思う。
- フレームワークのデフォルトのディレクトリ構成を変えてしまうというのは、時間があってしっかり構築したい場合は長い目線から言っていいのかもしれないけど、通常はフレームワークの良さを消しかねないとは思った
- ↑ > 設計にbestはありません。常にbetterを目指しましょう

---

## 第10章: 悪魔を呼び寄せる名前

### まとめ

- 関心の分離を考えた命名をする。ビジネス目的を名前として表現する(例：商品クラス ⇒ 在庫, 予約, 注文, 発送)
- 具体的で意味範囲の狭い特化した名前
    
    最重要。クラス自体も影響範囲も狭まる。仕様変更、変更時などの該当箇所を見つけるスピードが上がるなどの効果あり
    
- 存在ベースでなく目的ベース
    
    単純な名前よりも目的に応じた命名で混乱を防げる
    
    | 存在ベース | 目的ベース |
    | --- | --- |
    | 住所 | 配送元、発送先、勤務先 |
    | 金額 | 請求金額、消費税額、割引額 |
- 関心ごとの分析
    
    
- 声に出す
    
    ラバーダッキング ⇒ エラー発生時などに誰かに説明する過程で原因に気づくこと
    
- 利用規約を読む
    
    利用規約にサービスにおける用語の定義などがあり、クラス分割や命名の基準になる
    
- 違う名前に置き換えられるかの検討
    
    もっと狭い意味合いの名前があるかもしれない
    
- 疎結合高凝集の確認
    
    特化した名前は目的以外のロジックを寄せ付けにくくする。目的以外のロジックが入り込みそうなら命名の確認
    
- チーム開発では意識の共有が必要
- 仕様変更で意味合いが変化する場合は命名を見直す
- 命名することでロジックがコードに埋もれない
- 形容詞が出てきたら、それを意識した命名やクラス分割を考える(例：元々の価格、　補正された価格 など)
- 意図や目的を名前にする
- クラス分割の習慣がないと、「動詞 + 目的語」のメソッドが増えて責務の異なるものが混在しやすくなる。可能な限り「動詞」のみの命名ができるようにする
- bool返却のメソッドは「クラス名 + 状態」が正しい意味合いになるクラスへ実装する
- 基本的に名前は省略しない。一般名詞になっているもの、極めてスコープの小さい時のカウンタ変数などは例外的にOK。エディタが入力補完してくれるので面倒でもない

### メモ

- チーム内で意識を共有するとして、ドキュメントをどの程度作るのか？どの程度強制するのか？チェックはどうする？プロジェクトの期間はな大丈夫？など思いつくけど結局は何を重視するかのトレードオフになってしまう
- > 仕様変更で意味合いが変化する場合は命名を見直す ⇒ これ影響範囲考えるとかなり厳しい気がする。できるに越したことはないけどどうやればいいんだろう

## 第11章: コメント

### まとめ

- コメントはメンテナンスされにくい。かならず実装変更時はコメントも変更する ⇒ 退化コメント
- ロジックの挙動を再説明したコメントは書かない ⇒ 状態の追加のたびにコメントの編集が必要になる。メソッド名の再検討
- 「状態を追加する際はロジックの変更を検討」など、何に注意すれば安全に変更を加えられるかを重視してコメントする
- 実装の意図を説明するコメントにする
- ドキュメントコメントを書く(jsdocなど)

### メモ

- 長い処理になってしまう場合にコメントだけを読めば処理の流れがわかるようにとコメントを書いていたけどよくないらしい。そもそも処理を責務によって分割するのと、意図や注意点の補足となるようなコメントをするように。

## 第12章: メソッド(関数)

### まとめ

- 必ず自身のクラスのインスタンス変数を使う
- 変数は不変をベースにする
- getter/setterは低凝集に陥りやすい
- 「尋ねるな命じろ」で,呼び出される側で複雑な制御はするようにする
- コマンド・クエリ分離(CQS) ⇒ メソッドは変更,問い合わせどちらかのみを行うように設計する。例外的に両方(モディファイア)の場合もある。
- 引数は不変にする
- フラグ引数は使わない
- 出力引数は使わない(引数でインスタンスを渡して値を変更すること？)
- 引数は入力値を渡すことが基本
- 引数は少なくする
- 返り値はプリミティブ型じゃなくクラスの型を返すように
- nullは返さない
- 例外は返さない。投げる

### メモ